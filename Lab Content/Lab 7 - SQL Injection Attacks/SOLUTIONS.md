Lab 7 Solutions
======


### Challenge 1
The login page for the web application is vulnerable to SQL injection in the `username` field. Note that injection in the `password` field is not possible due to all passwords being hashed before being passed to the DBMS.

To bypass the form and log in as the `admin` user, we can manipulate the query by submitting `admin' #`.


### Challenge 2
The `changePassword.php` page's password field is vulnerable to SQL injection. Keep in mind that a) your input is likely being passed into an UPDATE query to reset the user's password, and b) the password is probably being hashed. 

When submitting the new password via the form input, we see an `id` parameter is being POSTED to the page. This `id` parameter maps to the id of the current user. 

If we want to update all users' passwords, we can manipulate the underlying query to match all users in the system by setting the id parameter as `1 OR 1=1`. Note that you must include your actual ID value in this request (i.e. `id=1`), otherwise the access control layer may deny your request.

Now, log in as any user using the password you specified!


### Challenge 3
On the `viewPost.php` page, we can see the ID of the post is passed in the URL in order to load its content. Manipulating this parameter indicates a SQL injection point.

We can manipulate this page to load data from the database instead of an actual post by loading an invalid post ID, followed by a UNION statement. 

First, we must determine the number of rows returned by the original query. This can be done by submitting a series of numeric results, such as `-1 UNION SELECT 1,2,3,4 #`. 

Next, we see that `3` shows up as the post title, and `4` as the post content when using the UNION query above. Therefore, we should insert our data in the 4th position in order to read the output. Note that column 3 is also a valid answer, but may truncate the result due to the expected string length.

We can find the version of the DMBS by triggering the MySQL `@@version` function using a query like `-1 UNION SELECT 1,2,3,@@version #`.


### Challenge 4
Leveraging the same SQL injection above, we can load the contents of `/var/lib/mysql-files/flag.txt` using the LOAD_FILE function build into MySQL. This can be placed in the same position as the `@@version` call above. 

The final query should be: `-1 UNION SELECT 1,2,3,LOAD_FILE('/var/lib/mysql-files/flag.txt') #`


### Challenge 5
The `searchPosts.php` is vulnerable to SQL injection via the search field (whose parameter name is `q`). To view all posts, simply submit a wildcard character (`%`). Note that the hidden post is still not shown, so perhaps there's a `WHERE` clause being used to check if the post is hidden. 

To remove this where clause, we can simply add a comment after our wildcard: `%' #`.


### Challenge 6
To enumerate all tables in the application, we will use the `searchPost.php` search field, like we did in challenge 5, since it returns multiple results. 

First, let's extend the query above to determine the number of columns that need to be returned: `%' UNION SELECT 1,2 #`. We see that column 1 is placed in the results table and is visible.

Next, let's enumerate the tables in the database using the information_schema and return them in column 1: `%' UNION SELECT table_name,2 FROM information_schema.tables #`. This reveals a hidden table called `secret`. 

To enumerate the columns in the table called `secret`, we can call the information schema again by doing: `%' UNION SELECT column_name,2 FROM information_schema.columns where table_name='secret' #`. This reveals the column `flag`. 

Finally, we can read all of the rows from the `secret` table's `flag` column by doing: `%' UNION SELECT flag,2 FROM secret #`.
